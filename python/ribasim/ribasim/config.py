# generated by datamodel-codegen:
#   filename:  Config.schema.json

from __future__ import annotations

from datetime import datetime
from typing import List, Optional, Union

from pydantic import BaseModel, Field


class Output(BaseModel):
    compression: Optional[str] = "zstd"
    basin: Optional[str] = "output/basin.arrow"
    flow: Optional[str] = "output/flow.arrow"
    control: Optional[str] = "output/control.arrow"
    outstate: Optional[str] = None
    compression_level: Optional[int] = 6


class LevelBoundary(BaseModel):
    time: Optional[str] = None
    static: Optional[str] = None


class Pump(BaseModel):
    static: Optional[str] = None


class DiscreteControl(BaseModel):
    logic: Optional[str] = None
    condition: Optional[str] = None


class Solver(BaseModel):
    reltol: Optional[float] = 0.001
    saveat: Optional[Union[List[float], float]] = []
    maxiters: Optional[int] = 1000000000
    autodiff: Optional[bool] = True
    adaptive: Optional[bool] = True
    algorithm: Optional[str] = "QNDF"
    abstol: Optional[float] = 1e-06
    dt: Optional[float] = 0
    sparse: Optional[bool] = True


class FlowBoundary(BaseModel):
    time: Optional[str] = None
    static: Optional[str] = None


class PidControl(BaseModel):
    time: Optional[str] = None
    static: Optional[str] = None


class FractionalFlow(BaseModel):
    static: Optional[str] = None


class ManningResistance(BaseModel):
    static: Optional[str] = None


class TabulatedRatingCurve(BaseModel):
    time: Optional[str] = None
    static: Optional[str] = None


class Logging(BaseModel):
    timing: Optional[bool] = False
    verbosity: Optional[str] = "info"


class Outlet(BaseModel):
    static: Optional[str] = None


class Terminal(BaseModel):
    static: Optional[str] = None


class Basin(BaseModel):
    profile: Optional[str] = None
    static: Optional[str] = None
    forcing: Optional[str] = None
    state: Optional[str] = None


class LinearResistance(BaseModel):
    static: Optional[str] = None


class Config(BaseModel):
    output: Optional[Output] = Field(
        default_factory=lambda: Output.parse_obj(
            {
                "basin": "output/basin.arrow",
                "flow": "output/flow.arrow",
                "control": "output/control.arrow",
                "outstate": None,
                "compression": "zstd",
                "compression_level": 6,
            }
        )
    )
    starttime: datetime
    update_timestep: Optional[float] = 86400
    input_dir: Optional[str] = "."
    output_dir: Optional[str] = "."
    level_boundary: Optional[LevelBoundary] = Field(
        default_factory=lambda: LevelBoundary.parse_obj({"static": None, "time": None})
    )
    pump: Optional[Pump] = Field(
        default_factory=lambda: Pump.parse_obj({"static": None})
    )
    discrete_control: Optional[DiscreteControl] = Field(
        default_factory=lambda: DiscreteControl.parse_obj(
            {"condition": None, "logic": None}
        )
    )
    solver: Optional[Solver] = Field(
        default_factory=lambda: Solver.parse_obj(
            {
                "algorithm": "QNDF",
                "saveat": [],
                "adaptive": True,
                "dt": 0,
                "abstol": 1e-06,
                "reltol": 0.001,
                "maxiters": 1000000000,
                "sparse": True,
                "autodiff": True,
            }
        )
    )
    flow_boundary: Optional[FlowBoundary] = Field(
        default_factory=lambda: FlowBoundary.parse_obj({"static": None, "time": None})
    )
    pid_control: Optional[PidControl] = Field(
        default_factory=lambda: PidControl.parse_obj({"static": None, "time": None})
    )
    fractional_flow: Optional[FractionalFlow] = Field(
        default_factory=lambda: FractionalFlow.parse_obj({"static": None})
    )
    relative_dir: Optional[str] = "."
    endtime: datetime
    manning_resistance: Optional[ManningResistance] = Field(
        default_factory=lambda: ManningResistance.parse_obj({"static": None})
    )
    tabulated_rating_curve: Optional[TabulatedRatingCurve] = Field(
        default_factory=lambda: TabulatedRatingCurve.parse_obj(
            {"static": None, "time": None}
        )
    )
    logging: Optional[Logging] = Field(
        default_factory=lambda: Logging.parse_obj(
            {"verbosity": {"level": 0}, "timing": False}
        )
    )
    outlet: Optional[Outlet] = Field(
        default_factory=lambda: Outlet.parse_obj({"static": None})
    )
    geopackage: str
    terminal: Optional[Terminal] = Field(
        default_factory=lambda: Terminal.parse_obj({"static": None})
    )
    basin: Optional[Basin] = Field(
        default_factory=lambda: Basin.parse_obj(
            {"forcing": None, "profile": None, "state": None, "static": None}
        )
    )
    linear_resistance: Optional[LinearResistance] = Field(
        default_factory=lambda: LinearResistance.parse_obj({"static": None})
    )
