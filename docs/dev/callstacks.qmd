# Call stacks

```{julia}
# | code-fold: true
# adapted from https://gist.github.com/mkborregaard/81825c3d370bb4d8dbfe59c3b2ae4b33
# by mkborregaard

using JuliaInterpreter, OrderedCollections
using Graphs, MetaGraphsNext

const callchains = OrderedSet{Vector{Method}}()
const modules = Set{Module}()

function callchain(frame::JuliaInterpreter.Frame)
    chain = Method[]
    sc = JuliaInterpreter.scopeof(frame)
    while sc isa Method
        push!(chain, sc)
        frame = frame.caller
        frame === nothing && break
        sc = JuliaInterpreter.scopeof(frame)
    end
    return chain
end

function log_far!(@nospecialize(recurse), frame, istoplevel::Bool=false)
    chain = callchain(frame)
    chain[1].module âˆˆ modules && push!(callchains, chain)
    return JuliaInterpreter.finish_and_return!(recurse, frame, istoplevel)
end

function encode_vertices(callchains)
    i = 0
    vertices = Dict{Array{Method},Int}()
    for chain in callchains
        for ind in length(chain):-1:1
            vert = chain[ind:end]
            haskey(vertices, vert) || (vertices[vert] = (i += 1))
        end
    end
    vertices
end

# per vertex: (module, name, file)
function getdata(vertices)
    data = Vector{NTuple{3, Symbol}}(undef, length(vertices))
    for (k, v) in vertices
        k1 = first(k)
        file = Symbol(last(split(String(k1.file), "\\")))
        data[v] = (Symbol(k1.module), k1.name, file)
    end
    data
end

@kwdef struct NodeMetadata
    i::Int
    mod::Symbol
    name::Symbol
    file::Symbol
    loc::Vector{Float64} = fill(NaN, 2)
    depth::Base.RefValue{Int} = Ref(0)
    isleaf::Base.RefValue{Bool} = Ref(false)
end

function Base.show(io::IO, nm::NodeMetadata)
    (; mod, name) = nm
    print(io, "$mod.$name")
end

function construct_graph(callchains)
    vertices = encode_vertices(callchains)
    data = getdata(vertices)

    graph = MetaGraph(
        DiGraph();
        label_type = Int,
        vertex_data_type = NodeMetadata
    )

    for (i, dat) in enumerate(data)
        mod, name, file = dat
        graph[i] = NodeMetadata(; i, mod, name, file)
    end

    for chain in callchains
        for ind in length(chain)-1:-1:1
            src = vertices[chain[ind+1:end]]
            dst = vertices[chain[ind:end]]
            graph[src, dst] = nothing
        end
    end

    graph, vertices
end

function tracecall(mods::Tuple, call, args)
    empty!(callchains)
    empty!(modules)
    for m in mods
        push!(modules, m)
    end
    frame = JuliaInterpreter.enter_call(call, args...)
    log_far!(log_far!, frame, false)
    construct_graph(callchains)
end

#############################################

using Ribasim
using SQLite
```

## Parameter initialization

```{julia}
toml_path = normpath(@__DIR__, "../../generated_testmodels/basic_transient/ribasim.toml")
config = Ribasim.Config(toml_path)
db_path = Ribasim.database_path(config)
db = SQLite.DB(db_path)

graph_orig, verts = tracecall((Ribasim,), Ribasim.Parameters, (db, config))
close(db)
```

```{julia}
graph = copy(graph_orig)

using GLMakie
using Colors

f = Figure()
ax = Axis(f[1, 1])

# Options
maxdepth = 5
plot_non_Ribasim = false
squash_per_depth = true

# Get node depths
depths = dijkstra_shortest_paths(graph, 1).dists
nodes_per_depth = Dict(Int(depth) => Int[] for depth in unique(depths))

for (i, depth) in enumerate(depths)
    nm = graph[i]
    nm.depth[] = depth
    nm.loc[1] = depth

    push!(nodes_per_depth[Int(depth)], i)
end

# Squash per depth nodes with the same name into one
function squash!(graph, nodes_per_depth)
    for depth in 1:maxdepth
        names = Dict{String, Vector{Int}}()
        nodes_at_depth = nodes_per_depth[depth]
        for i in nodes_at_depth
            nm = graph[i]
            name = "$nm"
            if name in keys(names)
                push!(names[name], i)
            else
                names[name] = [i]
            end
        end
        for nodes in values(names)
            (length(nodes) == 1) && continue
            survivor = first(nodes)

            for i in nodes[2:end]
                for i_in in inneighbor_labels(graph, i)
                    graph[i_in, survivor] = nothing
                    delete!(graph, i_in, i)
                end

                for i_out in outneighbor_labels(graph, i)
                    graph[survivor, i_out] = nothing
                    delete!(graph, i, i_out)
                end

                delete!(graph, i)
                deleteat!(nodes_at_depth, findfirst(==(i), nodes_at_depth))
            end
        end
    end
end

squash_per_depth && squash!(graph, nodes_per_depth)

# Sort nodes by file for each depth
for nodes in values(nodes_per_depth)
    sort!(nodes, by = i -> graph[i].file)
end

# Set node coordinates
for depth in 0:maxdepth
    nodes = nodes_per_depth[depth]
    n_nodes = if plot_non_Ribasim
        length(nodes)
    else
        count(i -> graph[i].mod == :Ribasim, nodes)
    end
    ys = n_nodes == 1 ? [0] : range(-1, 1, length = n_nodes)
    idx = 1

    for i in nodes
        nm = graph[i]
        if (nm.mod == :Ribasim || plot_non_Ribasim)
            graph[i].loc .= (depth, ys[idx])
            idx += 1
        end
    end
end

# Plot edges
for edge in edges(graph)
    nm_src = graph[label_for(graph, edge.src)]
    nm_dst = graph[label_for(graph, edge.dst)]

    (nm_dst.depth[] > maxdepth) && continue

    x = [nm_src.loc[1], nm_dst.loc[1]]
    y = [nm_src.loc[2], nm_dst.loc[2]]
    lines!(ax, x, y; color = :black)
end

# Plot node labels
files = sort(unique(graph[i].file for i in labels(graph) if graph[i].mod == :Ribasim), rev = true)
colors = distinguishable_colors(length(files)+1)[2:end]
color_dict = OrderedDict(zip(files, colors))

get_color(file) = get(color_dict, file, :black)

for node in labels(graph)
    nm = graph[node]
    (nm.depth[] > maxdepth) && continue
    color = nm.mod == :Ribasim ? :green : :black
    text!(ax, nm.loc...,
        text = "$nm",
        color = get_color(nm.file),
        font = :bold,
        strokecolor = :black,
        strokewidth = 1,
        label = String(nm.file)
    )
end

Legend(
    f[1,2],
    [MarkerElement(color = c, marker = :rect) for c in values(color_dict)],
    String.(files)
)

f
```

```{julia}
# TODO:
# - Fix y coordinate of nodes that have no outneighbors
# - Remove nodes (and everything downstream) from non-Ribasim calls
# - Color boxes by file name and add legend
# - Add boxes around names
# - Let connection lines emerge from box boundaries
```
