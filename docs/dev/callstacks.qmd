# Call stacks

```{julia}
# | code-fold: true
# adapted from https://gist.github.com/mkborregaard/81825c3d370bb4d8dbfe59c3b2ae4b33
# by mkborregaard

using JuliaInterpreter, OrderedCollections
using Graphs, MetaGraphsNext

const callchains = OrderedSet{Vector{Method}}()
const modules = Set{Module}()

function callchain(frame::JuliaInterpreter.Frame)
    chain = Method[]
    sc = JuliaInterpreter.scopeof(frame)
    while sc isa Method
        push!(chain, sc)
        frame = frame.caller
        frame === nothing && break
        sc = JuliaInterpreter.scopeof(frame)
    end
    return chain
end

function log_far!(@nospecialize(recurse), frame, istoplevel::Bool=false)
    chain = callchain(frame)
    chain[1].module ∈ modules && push!(callchains, chain)
    return JuliaInterpreter.finish_and_return!(recurse, frame, istoplevel)
end

function encode_vertices(callchains)
    i = 0
    vertices = Dict{Array{Method},Int}()
    for chain in callchains
        for ind in length(chain):-1:1
            vert = chain[ind:end]
            haskey(vertices, vert) || (vertices[vert] = (i += 1))
        end
    end
    vertices
end

# per vertex: (module, name, file)
function getdata(vertices)
    data = Vector{Tuple{Symbol, Symbol, Symbol, Int}}(undef, length(vertices))
    for (k, v) in vertices
        k1 = first(k)
        file = Symbol(last(split(String(k1.file), "\\")))
        data[v] = (Symbol(k1.module), k1.name, file, k1.line)
    end
    data
end

@kwdef struct NodeMetadata
    i::Int
    mod::Symbol
    name::Symbol
    file::Symbol
    line::Int
    loc::Vector{Float64} = fill(NaN, 2)
    depth::Base.RefValue{Int} = Ref(0)
    isleaf::Base.RefValue{Bool} = Ref(false)
end

function Base.show(io::IO, nm::NodeMetadata)
    (; mod, name, line) = nm
    print(io, "$mod.$name (L$line)")
end

function construct_graph(callchains)
    vertices = encode_vertices(callchains)
    data = getdata(vertices)

    graph = MetaGraph(
        DiGraph();
        label_type = Int,
        vertex_data_type = NodeMetadata
    )

    for (i, dat) in enumerate(data)
        mod, name, file, line = dat
        graph[i] = NodeMetadata(; i, mod, name, file, line)
    end

    for chain in callchains
        for ind in length(chain)-1:-1:1
            src = vertices[chain[ind+1:end]]
            dst = vertices[chain[ind:end]]
            graph[src, dst] = nothing
        end
    end

    graph, vertices
end

function tracecall(mods::Tuple, call, args)
    empty!(callchains)
    empty!(modules)
    for m in mods
        push!(modules, m)
    end
    frame = JuliaInterpreter.enter_call(call, args...)
    log_far!(log_far!, frame, false)
    construct_graph(callchains)
end

#############################################

using CairoMakie
using Colors

function cut_generated_calls!(graph)
    for i in collect(labels(graph))
        nm = graph[i]
        (; name) = nm
        if startswith(String(name), "#")
            for i_in in inneighbor_labels(graph, i)
                for i_out in outneighbor_labels(graph, i)
                    graph[i_in, i_out] = nothing
                end
            end
            delete!(graph, i)
        end
    end
end

function get_node_depths(graph)
    depths = dijkstra_shortest_paths(graph, 1).dists
    nodes_per_depth = Dict(Int(depth) => Int[] for depth in unique(depths))

    for (i, depth) in zip(labels(graph), depths)
        nm = graph[i]
        nm.depth[] = depth
        nm.loc[1] = depth

        push!(nodes_per_depth[Int(depth)], i)
    end

    # Sort nodes by file for each depth
    for nodes in values(nodes_per_depth)
        sort!(nodes, by = i -> graph[i].file, rev = true)
    end

    return nodes_per_depth
end

function squash!(graph, nodes_per_depth, max_depth, squash_methods)
    for depth in 1:max_depth
        names = Dict{String, Vector{Int}}()
        nodes_at_depth = nodes_per_depth[depth]
        for i in nodes_at_depth
            nm = graph[i]
            name = if nm.name in squash_methods
                "$(nm.mod).$(nm.name)"
            else
                "$nm"
            end
            if name in keys(names)
                push!(names[name], i)
            else
                names[name] = [i]
            end
        end
        for nodes in values(names)
            (length(nodes) == 1) && continue
            survivor = first(nodes)

            for i in nodes[2:end]
                for i_in in inneighbor_labels(graph, i)
                    graph[i_in, survivor] = nothing
                    delete!(graph, i_in, i)
                end

                for i_out in outneighbor_labels(graph, i)
                    graph[survivor, i_out] = nothing
                    delete!(graph, i, i_out)
                end

                delete!(graph, i)
                deleteat!(nodes_at_depth, findfirst(==(i), nodes_at_depth))
            end
        end
    end
end

function set_coordinates!(graph, nodes_per_depth, max_depth, plot_non_Ribasim)
    for depth in 0:max_depth
        nodes = nodes_per_depth[depth]
        n_nodes = if plot_non_Ribasim
            length(nodes)
        else
            count(i -> graph[i].mod == :Ribasim, nodes)
        end
        ys = n_nodes == 1 ? [0] : range(-1, 1, length = n_nodes)
        idx = 1

        for i in nodes
            nm = graph[i]
            if (nm.mod == :Ribasim || plot_non_Ribasim)
                graph[i].loc .= (depth, ys[idx])
                idx += 1
            end
        end
    end
end

function plot_edges!(ax, graph, max_depth, n_points = 25)
    for edge in edges(graph)
        nm_src = graph[label_for(graph, edge.src)]
        nm_dst = graph[label_for(graph, edge.dst)]

        (nm_dst.depth[] > max_depth) && continue

        A = (nm_src.loc[2] - nm_dst.loc[2]) / 2
        B = π / (nm_dst.loc[1] - nm_src.loc[1])
        C = (nm_src.loc[2] + nm_dst.loc[2]) / 2

        x = range(nm_src.loc[1], nm_dst.loc[1], length = n_points)
        y = @. A * cos(B * (x - nm_src.loc[1])) + C

        lines!(ax, x, y; color = :black)
    end
end

function plot_labels!(ax, graph, max_depth, color_dict)
    for node in labels(graph)
        nm = graph[node]
        x, y = nm.loc
        (nm.depth[] > max_depth) && continue
        text!(ax, x, y,
            text = "$nm",
            color = get(color_dict, nm.file, :black),
            font = :bold,
            strokecolor = :black,
            strokewidth = 0.5,
            label = String(nm.file),
            align = (:center, :bottom)
        )
        scatter!(ax, [x], [y], color = :black)
    end
end

function plot_graph(
    graph_orig::MetaGraph;
    size = (1000,1000),
    max_depth::Int = 5,
    plot_non_Ribasim::Bool = false,
    squash_per_depth::Bool = true,
    squash_methods::Vector{Symbol} = Symbol[],
)
    delete!(theme(nothing), :resolution) # Needed because of a refactor in Makie going from resolution to size
    f = Figure(; size = size)
    ax = Axis(f[1, 1])

    graph = copy(graph_orig)

    # Cut out calls whose name starts with '#'
    cut_generated_calls!(graph)

    nodes_per_depth = get_node_depths(graph)

    # Squash per depth nodes with the same name into one
    squash_per_depth && squash!(graph, nodes_per_depth, max_depth, squash_methods)

    set_coordinates!(graph, nodes_per_depth, max_depth, plot_non_Ribasim)
    plot_edges!(ax, graph, max_depth)

    files = sort(unique(graph[i].file for i in labels(graph) if graph[i].mod == :Ribasim))
    colors = distinguishable_colors(length(files)+1)[end:-1:2]
    color_dict = OrderedDict(zip(files, colors))

    plot_labels!(ax, graph, max_depth, color_dict)

    Legend(
        f[1,2],
        [MarkerElement(color = c, marker = :rect) for c in values(color_dict)],
        String.(files)
    )

    f
end

#############################################

using Ribasim
```

## Parameter initialization

```{julia}
# | code-fold: true
using SQLite
toml_path = normpath(@__DIR__, "../../generated_testmodels/basic_transient/ribasim.toml")
config = Ribasim.Config(toml_path)
db_path = Ribasim.database_path(config)
db = SQLite.DB(db_path)

graph, verts = tracecall((Ribasim,), Ribasim.Parameters, (db, config))
close(db)

plot_graph(
    graph;
    size = (1500, 1200),
    squash_methods = [
        :n_neighbor_bounds_flow,
        :n_neighbor_bounds_control,
        :sort_by_function,
        :neighbortypes
    ]
)
```

## Water balance

```{julia}
# | code-fold: true
using OrdinaryDiffEqCore: get_du
model = Ribasim.Model(toml_path)
du = get_du(model.integrator)
(; u, p, t) = model.integrator
graph, verts = tracecall((Ribasim,), Ribasim.water_balance!, (du, u, p, t))
plot_graph(graph)
```

```{julia}
# TODO:
# - Fix y coordinate of nodes that have no outneighbors
# - Remove nodes (and everything downstream) from non-Ribasim calls
# - Color boxes by file name and add legend
# - Add boxes around names
# - Let connection lines emerge from box boundaries
```
