---
title: "Allocation"
---

# The `Allocation` struct
Object for all information about allocation
entry                   |  description
-----------------       |  -----------

subnetwork_ids          | The unique sorted allocation network IDs
allocation_models       | The allocation models for the main network and subnetworks corresponding to subnetwork_ids
main_network_connections| (from_id, to_id) from the main network to the subnetwork per subnetwork
priorities              | All used priority values.
subnetwork_demands      | The demand of an edge from the main network to a subnetwork
subnetwork_allocateds   | The allocated flow of an edge from the main network to a subnetwork
mean_input_flows        | Flows averaged over Δt_allocation over edges that are allocation sources
mean_realized_flows     | Flows averaged over Δt_allocation over edges that realize a demand
record_demand           | A record of demands and allocated flows for nodes that have these
record_flow             | A record of all flows computed by allocation optimization, eventually saved to output file

# Initialization
What the file of `allocation.jl`is for. Below is the steps of allocation problem initialization

For each subnetwork, a allocation problem.

## Data processing
### Deriving edge capacities

Obtaining the capacities of all the flow edges in subnetwork. Stored in a SparseArray object from JuMP called `capacities` indexed by the `edge_metadata.edge`

Function `get_capacity` can obtain SparseArray object given a subnetwork id and ribasim model parameter `p`, if the source of the subnetwork is valid (), it will return capacity.

### Handling the connection between the main network and subnetworks
function find_subnetwork_connetions will find the edges connect the main network and a subnetwork. `subnetwork_demands` and `subnetwork_allocateds` will be created
`main_network_connection` is a vector of edge that connect subnetwork with main network

## Optimization problem
### Setting up optimization variables
There are three sets of variable in the optimization problems. They are flows between the edges in allocation model, flows basin connect with a level demand node and flows of nodes that connect with flow demand or fractional flow outneighbors.

In the code below, flow edges are retracted from capacity array. And variable named by `F($startnode, $endnode)` are created.

```julia
function add_variables_flow!(
    problem::JuMP.Model,
    capacity::JuMP.Containers.SparseAxisArray{Float64, 2, Tuple{NodeID, NodeID}},
)::Nothing
    edges = keys(capacity.data)
    problem[:F] = JuMP.@variable(problem, F[edge = edges] >= 0.0)
    return nothing
end
```

In the following code block, variable that represent flows of thoes basins that connected with level demand are defined. The variable is named `F_basin_in` if basin supplied by the basins with a level demand and `F_basin_out` if consumed by a level demand.

```julia
function add_variables_basin!(
    problem::JuMP.Model,
    p::Parameters,
    subnetwork_id::Int32,
)::Nothing
    (; graph) = p

    # Get the node IDs from the subnetwork for basins that have a level demand
    node_ids_basin = [
        node_id for
        node_id in graph[].node_ids[subnetwork_id] if graph[node_id].type == :basin &&
        has_external_demand(graph, node_id, :level_demand)[1]
    ]
    problem[:F_basin_in] =
        JuMP.@variable(problem, F_basin_in[node_id = node_ids_basin,] >= 0.0)
    problem[:F_basin_out] =
        JuMP.@variable(problem, F_basin_out[node_id = node_ids_basin,] >= 0.0)
    return nothing
end
```

The last set of optimization variables are the flows with  flow demand or fractional flow outneighbors. It is defined in a similar way to the second set of variables.

### Setting up optimization constraints
All the variable are greater and equal to 0. This is set when the variable are added to the optimization problem.

Other constrains are capacity, source_user, source and flow_conservation, fractional_flow, basin_outflow, flow_buffer_outflow and flow_demand_outflow.

For each set of constrains, a function named `add_constrains_[constrains name]` is created.

Take `add_constraints_user_source` as an example, the node that is relevant to the constrains are filtered. Then a set of constrains are added by calling JuMP.`@`constraint.

```julia
    node_ids_user = [node_id for node_id in node_ids if node_id.type == NodeType.UserDemand]

    problem[:source_user] = JuMP.@constraint(
        problem,
        [node_id = node_ids_user],
        F[(node_id, outflow_id(graph, node_id))] <= 0.0,
        base_name = "source_user"
    )
```

# Optimization

## Preparing the optimization problem
### Setting up the objective function
The objective function is defined here here code
### Setting the constraints and capacities

## Looping over priorities
### Updating capacities

## Output data

## Communicating to the physical layer

### `UserDemand` abstraction
### Controlling pumps/weirs based on allocation results (n/a)
