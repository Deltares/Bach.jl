---
title: "Interpolation"
---

Interpolation is a significant part of the Ribasim core, which is why this page is dedicated to which interpolation types are used, and how edge cases are handled. For most interpolation functionality in the core we use the package [DataInterpolations.jl](https://docs.sciml.ai/DataInterpolations/stable/).

# Basin profiles

_General description from Fatima?_

## Level to area

The level to area relationship is defined with the `Basin / profile` data using linear interpolation. An example of such a relationship is shown below.

```{python}
# | code-fold: true
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.display import display, Markdown

np.random.seed(3)
fig, ax = plt.subplots()
fontsize = 15

# Data
N = 3
area = 25 * np.cumsum(np.random.rand(N))
level = np.cumsum(np.random.rand(N))

# Interpolation
ax.scatter(level,area, label = "data")
ax.plot(level,area, label = "interpolation")
ax.set_xticks([level[0], level[-1]])
ax.set_xticklabels(["bottom", "last supplied level"])
ax.set_xlabel("level", fontsize = fontsize)
ax.set_ylabel("area", fontsize = fontsize)
ax.set_yticks([0])

# Extrapolation
level_extrap = 2 * level[-1] - level[-2]
area_extrap = 2 * area[-1] - area[-2]
ax.plot([level[-1], level_extrap], [area[-1], area_extrap], color = "C0", ls = "dashed", label = "extrapolation")
xlim = ax.get_xlim()
ax.set_xlim(xlim[0], (level[-1] + level_extrap)/2)

ax.legend()
fig.tight_layout()

markdown_table = pd.DataFrame(
        data = {
            "level" : level,
            "area" : area
        }
    ).to_markdown(index = False)

display(Markdown(markdown_table))
```

For this interpolation it is validated that:

- The areas are positive and are non-decreasing;
- There are at least 2 data points.

This interpolation is used in each evaluation of the right hand side function of the ODE.

## Level to storage

The level to storage relationship gives the volume of water in the basin at a given level, which is given by the integral over the level to area relationship from the basin bottom to the given level:

$$
    S(l) = \int_{l_0}^l A(l')\text{d}l'.
$$

```{python}
# | code-fold: true
storage = np.diff(level) * area[:-1] + 0.5 * np.diff(area) * np.diff(level)
storage = np.cumsum(storage)
storage = np.insert(storage, 0, 0.0)
def S(l):
    i = min(max(0, np.searchsorted(level, l)-1), len(level)-2)
    return storage[i] + area[i] * (l - level[i]) + 0.5 * (area[i+1] - area[i]) / (level[i+1] - level[i]) * (l - level[i])**2

S = np.vectorize(S)

# Interpolation
fig, ax = plt.subplots()
level_eval = np.linspace(level[0], level[-1], 100)
storage_eval = S(np.linspace(level[0], level[-1], 100))
ax.scatter(level, storage, label = "storage at datapoints")
ax.plot(level_eval, storage_eval, label = "interpolation")
ax.set_xticks([level[0], level[-1]])
ax.set_xticklabels(["bottom", "last supplied level"])
ax.set_yticks([0])
ax.set_xlabel("level", fontsize = fontsize)
ax.set_ylabel("storage", fontsize = fontsize)

# Estrapolatnio
level_eval_extrap = np.linspace(level[-1], level_extrap, 35)
storage_eval_extrap = S(level_eval_extrap)
ax.plot(level_eval_extrap, storage_eval_extrap, color = "C0", linestyle = "dashed", label = "extrapolation")
xlim = ax.get_xlim()
ax.set_xlim(xlim[0], (level[-1] + level_extrap)/2)
ax.legend()
```

for converting the initial state in terms of levels to an initial state in terms of storages used in the core.

```{python}
# | code-fold: true

from dash import html, dcc, Dash
import plotly.graph_objects as go
from dash.dependencies import Input, Output, State

fig = go.Figure()
fig.update_layout(uirevision='constant')

def linear_interpolation(X,Y,x):
    i = min(max(0, np.searchsorted(X, x)-1), len(X)-2)
    return Y[i] + (Y[i+1] - Y[i])/(X[i+1] - X[i]) * (x - X[i])

def A(l):
    return linear_interpolation(level, area, l)

A = np.vectorize(A)

def L(a):
    if a < area[0]:
        return level[0]
    else:
        return linear_interpolation(area, level, a)

L = np.vectorize(L)

length = 8.5
X = np.linspace(-length/2, length/2, 100)

y_max = area[-1] / (2 * length)
Y = np.linspace(-y_max, y_max, 100)
X, Y = np.meshgrid(X, Y)

Z = L(2*length*np.abs(Y))


# Profile data
customdata = np.stack((A(Z).T, S(Z).T), axis = 2)
hovertemplate = (
    "<b>level</b>: %{z:.3f}<br>"
    "<b>area</b>: %{customdata[0]:.3f}<br>"
    "<b>storage</b>: %{customdata[1]:.3f}"
    "<extra></extra>"
)

# The basin
fig.add_trace(
    go.Surface(x=X, y=Y, z=Z,
        hoverinfo = "text",
        hovertemplate=hovertemplate,
        customdata = customdata,
        name = "Basin",
        showlegend = True,
        showscale = False,
        colorscale=[[0, 'brown'], [1, 'brown']]
    )
)

# The water level
z_start = level[1]
y_start = area[1] / (2 * length)

fig.add_trace(
    go.Surface(
        x=[[-length/2, length/2], [-length/2, length/2]],
        y=[[-y_start, -y_start], [y_start, y_start]],
        z=[[z_start, z_start], [z_start, z_start]],
        opacity=0.7,
        showscale=False,
        hoverinfo='skip',
        name='Water level',
        showlegend = True,
        colorscale=[[0, 'blue'], [1, 'blue']]
    )
)

fig.update_layout(
    scene=dict(
        aspectmode='data'
    )
)

# Create a Dash app
app = Dash(__name__)

# Create the app layout
app.layout = html.Div([
    dcc.Graph(id='graph', figure=fig),
    dcc.Store(id='hover-data')
])

# Clientside callback to update hover-data
app.clientside_callback(
    """
    function(hoverData) {
        return hoverData;
    }
    """,
    Output('hover-data', 'data'),
    Input('graph', 'hoverData')
)

# Callback to update the graph
@app.callback(
    Output('graph', 'figure'),
    Input('hover-data', 'data'),
    State('graph', 'figure')
)
def update_graph(hover_data, fig):
    if hover_data:
        if 'points' in hover_data and len(hover_data['points']) > 0:
            basin_bottom = fig["data"][0]['z'][50][50]
            hover_point = hover_data['points'][0]
            y = abs(hover_point['y'])
            z = hover_point['z']
            water_level = fig['data'][1]

            if z <= basin_bottom:
                # Basin is empty, give water level zero extent
                water_level['y'] = [[0, 0], [0, 0]]
            else:
                water_level['y'] = [[-y, -y], [y, y]]

            water_level['z'] = [[z, z], [z, z]]
    return fig

# Run the app
app.run_server()
```


## Storage to level

The level is computed from the storage by inverting the level to storage relationship shown above. See [here](https://docs.sciml.ai/DataInterpolations/stable/inverting_integrals/) for more details.

# Basin Forcings

Basin forcings, as specified in `Basin / static` or `Basin / time`, are interpolated with forward fill. This looks as follows.

```{python}
# | code-fold: true

fig, ax = plt.subplots()

N = 5
y = np.random.rand(N)
x = np.cumsum(np.random.rand(N))

def forward_fill(x_):
    i = min(max(0, np.searchsorted(x, x_)-1), len(x)-1)
    return y[i]

def plot_forward_fill(i):
    ax.plot([x[i], x[i+1]], [y[i], y[i]], color = "C0", label = "interpolation" if i == 0 else None)

ax.scatter(x[:-1],y[:-1], label = "forcing at data points")
for i in range(N-1):
    plot_forward_fill(i)

x_missing_data = np.sort(x[0] + (x[-1] - x[0]) * np.random.rand(5))
y_missing_data = [forward_fill(x_) for x_ in x_missing_data]
ax.scatter(x_missing_data, y_missing_data, color = "C0", marker = "x", label = "missing data")
ax.set_xticks([])
ax.set_yticks([])
ax.set_xlabel("time", fontsize = fontsize)
ax.set_ylabel("forcing", fontsize = fontsize)
xlim = ax.get_xlim()
ax.set_xlim(xlim[0], (x[-2] + x[-1])/2)
ax.legend()
```

As shown this interpolation type supports missing data, and just maintains the last available value. Because of this for instance precipitation can be updated while evaporation stays the same.

# Concentrations

# Tabulated Rating Curve

The $Q(h)$ relationship of a tabulated rating curve is defined as a linear interpolation.

```{python}
# | code-fold: true
N = 10
level = np.cumsum(np.random.rand(N))
flow = level**2 + np.random.rand(N)
flow[0] = 0.0
fig, ax = plt.subplots()
ax.set_xticks([])
ax.set_yticks([0])
ax.scatter(level, flow, label = "data")
ax.plot(level, flow, label = "interpolation", color = "C0")
ax.plot([level[0] - 1, level[0]], [0, 0], label = "extrapolation", linestyle = "dashed")
ax.legend()
ax.set_xlabel("level", fontsize = fontsize)
ax.set_ylabel("flow", fontsize = fontsize)

level_extrap = 2 * level[-1] - level[-2]
flow_extrap = 2 * flow[-1] - flow[-2]
ax.plot([level[-1], level_extrap], [flow[-1], flow_extrap], color = "C0", linestyle = "dashed")
ax.set_xlim(level[0] - 0.5, (level[-1] + level_extrap)/2)
```

Here it is validated that the flow starts at $0$ and is non-decreasing.

The flow is extrapolated as 0 backward and linearly forward.

# Level Boundary

# Flow Boundary

# Continuous Control

# Pid Control

# User Demand

# Level Demand (min max level)

# Flow Demand

# Subgrid
