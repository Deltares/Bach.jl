---
title: "How to add a new node type"
---

Several parts of the code have to be made aware of the new node type. In the rest of this page we shall call our new node type `NewNodeType`.

# The Julia core

## Parameters

The parameters object (defined in `solve.jl`) passed to the ODE solver must be made aware of the new node type. Therefore define a struct in `solve.jl` which holds the data for each node of the new node type:

```julia
struct NewNodeType
    node_id::Vector{Int}
    # Other fields
end
```

This struct should at least contain a vector of all node IDs that are of the new type in a given model. Now you can:

- add `new_node_type::NewNodeType` to the Parameters object;
- add `new_node_type = NewNodeType(db,config)` to the function `Parameters` in create.jl and add new_node_type add the proper location in the `Parameters` constructor call.

## Reading from configuration

To define a schema for the new node type, add the following to `validation.jl`:

```julia
@version NewNodeTypeV1 begin
	node_id::Int
	# Other fields
end
```

Now we define the function that is called in the second bullet above, in `create.jl`:

```julia
function NewNodeType(db::DB, config::Config)::NewNodeType
	static = load_structvector(db, config, NewNodeTypeV1)

	# Unpack the fields of static as inputs for the NewNodeType constructor
	return NewNodeType(static.node_id, static.some_property)
end
```

## Node behaviour

The behaviour of the new node in the Ribasim core is defined in a method of the `formulate!` function, which is called within the `water_balance!` (both in `solve.jl`) function being the right hand side of the system of differential equations solved by Ribasim. Here the details depend highly on the specifics of the node type. An example structure of a `formulate!` method is given below.

```julia
function formulate!(new_node_type::NewNodeType, p::Parameters)::Nothing
	# Retrieve relevant parameters
	(; connectivity) = p
	(; flow) = connectivity
	(; node_id, param_1, param_2) = new_node_type

	# Loop over nodes of NewNodeType
	for (i, id) in enumerate(node_id)
		# compute e.g. flow based on param_1[i], param_2[i]
	end 

	return nothing
end 
```


# Python I/O

## Python class

Create a new file `python/ribasim/ribasim/new_node_type.py` which is structured as follows:

```python
import pandas as pd
import pandera as pa
from pandera.typing import DataFrame, Series
from pydantic import baseModel

from ribasim.input_base import InputMixin

__all__ = ("NewNodeType",)

class StaticSchema(pa.SchemaModel):
    node_id: Series[int] = pa.Field(coerce=True)
    # Series per node property, pa.Field for mandatory data

# Possible other schemas


class NewNodeType(InputMixin, BaseModel):
    """
    Description of this node type.

    Parameters
    ----------
    static: pandas.DataFrame
        table with data for this node type.

    possible other schemas
    """

    _input_type = "NewNodeType"
    static: Optional[DataFrame[StaticSchema]] = None
    # possible other schemas

    class Config:
        validate_assignment = True

```

in `python/ribasim/ribasim/model.py`, add

- `from ribasim.new_node_type import NewNodeType`;
- `(NewNodetype, "new_node_type")` in the `_NODES` list;
- new_node_type as a parameter and in the docstring of the `Model` class.


# QGIS plugin

The script `qgis\core\nodes.py` has to be updated to specify how the new node type is displayed by the QGIS plugin. Specifically:

- Add `"NewNodeType: NewNodeType",` to the `"map"` dictionary in `Node.set_editor_widget`; 
- Add a color and shape discription in the `markers` dictionary in `Node.renderer`.
- Add an input class per schema, e.g. 

```python
class NewNodeTypeStatic
    input_type = "NewNodeType / static"
    geometry_type = "No Gemoetry"
    attributes = [
        QgsField("node_id", QVariant.Int)
        # Other fields for properties of this node
    ]
```

and add these to the NODES dictionary.


# Tests

Models for the julia tests are generated by running `python/ribasim/tests/conftest.py`. These models should also be updated to contain the new node type. Note that certain tests must be updated accordingly when the models used for certain tests are updated, e.g. the final state of the models in `core/test/basin.jl`.

Future:
- Test for the specific behaviour of each node type


# Documentation

There are several parts of the documentation which should be updated with the new node type:

- `docs/core/equations` should contain a short explanation and if possible an analytical expression for the behaviour of the new node;
- `docs\core\usage.qmd` should conntain a short explanation of the node and the possible schemas associated with it;
- The example models constructed in `docs/python/examples.ipynb` should be extended with the new node type or a new example model with the new node type should be made.

# Finishing up 

When a new node type is created, one needs to run

```
julia --project=docs docs/gen_schema.jl
```
to create new jsonschemas in the docs folder, and

```
datamodel-codegen --use-title-as-name --input docs/schema/root.schema.json --output python/ribasim/ribasim/models.py
```
to generate the Python models from it.

This should be followed by `black python` to format the generated code.