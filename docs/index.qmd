---
title: "Ribasim"
---

Ribasim is a water resources model, designed to be the replacement of the regional surface
water modules Mozart and SIMRES in the Netherlands Hydrological Instrument (NHI). Ribasim is
a work in progress, it is a prototype that demonstrates all essential functionalities.
Further development of the prototype in a software release is planned in 2022 and 2023.

Ribasim is written in the [Julia programming language](https://julialang.org/) and is built
on top of the [SciML: Open Source Software for Scientific Machine Learning](https://sciml.ai/)
libraries, notably [ModelingToolkit.jl](https://mtk.sciml.ai/stable/).

::: {layout-ncol=2 layout-valign="bottom"}
<a href="https://www.deltares.nl/">
    <img alt="Deltares logo"
        src="https://user-images.githubusercontent.com/4471859/187672447-adb9cb11-16ca-488b-bef9-08e059fe6d55.svg"
        height="60">
</a>

<a href="https://nhi.nu/">
    <img alt="NHI logo"
        src="https://user-images.githubusercontent.com/4471859/187672456-874b344a-9ad3-42b5-af6a-93517f7fbbe8.png"
        height="60">
</a>
:::

# Status

The initial focus is on being able to
reproduce the Mozart regional surface water reservoir results. Each component is defined by
a set of symbolic equations, and can be connected to each other. From this a simplified
system of equations is generated automatically. We use solvers with adaptive time stepping
from [DifferentialEquations.jl](https://diffeq.sciml.ai/stable/) to get results.

![Example timeseries of a single basin, the Hupselse Beek, with the input and output fluxes on the top, and the storage volume (the state) below.](https://user-images.githubusercontent.com/4471859/179259333-070dfe18-8f43-4ac4-bb38-013b252e2e4b.png)

![Example bar plot of the daily waterbalance for the Hupselse Beek, comparing results of Mozart (left) and Ribasim (right).](https://user-images.githubusercontent.com/4471859/179259174-0caccd4a-c51b-449e-873c-17d48cfc8870.png)


# Introduction
## Water balance equations

The water balance equation for a drainage basin [@enwiki:1099736933] can be
defined by a first-order ordinary differential equation (ODE), where the change of
the storage $S$ over time is determined by the inflow fluxes minus the outflow
fluxes.

$$
\frac{\mathrm{d}S}{\mathrm{d}t} = Q_{in} - Q_{out}
$$

We can split out the fluxes into separate terms, such as precipitation $P$,
evapotranspiration $ET$ and runoff $R$. For now other fluxes are combined into
$Q_{rest}$. If we define all fluxes entering our reservoir as positive, and those
leaving the system as negative, all fluxes can be summed up.

$$
\frac{\mathrm{d}S}{\mathrm{d}t} = R + P + ET + Q_{rest}
$$

Such a water balance ODE can be represented in ModelingToolkit.jl as follows:

```julia
using ModelingToolkit

@variables t S(t) R(t) P(t) ET(t) Q_rest(t)  # independent and dependent variables
D = Differential(t)       # define an operator for the differentiation w.r.t. time

sys = ODESystem([D(S) ~ R + P + ET + Q_rest])
```

On the last line, an `ODESystem` is created that consists of a single equation. Before we
can solve this, we need to create an `ODEProblem`, that provides information about the
timespan of the simulation, as well as the initial conditions.

Ribasim can be used as a Julia package running in a Julia session or as an
application initialized via a TOML configuration file. Both use cases are
shown in the demonstrations.

## Time

The water balance equation can be applied on many timescales; years, weeks, days or hours.
Depending on the application and available data any of these can be the best choice.
In Ribasim, we make use of DifferentialEquations.jl and its [ODE solvers](https://diffeq.sciml.ai/stable/solvers/ode_solve/).
Many of these solvers are based on adaptive time stepping, which means the solver will
decide how large the time steps can be depending on the state of the system.

The forcing, like precipitation, is generally provided as a time series. Ribasim is set up
to support unevenly spaced timeseries. The solver will stop on timestamps where new forcing
values are available, so they can be loaded as the new value.
 
Ribasim is essentially a continuous model, rather than daily or hourly. If you want to use
hourly forcing, you only need to make sure that your forcing data contains hourly updates.
The output frequency can be configured independently. To be able to write a closed water
balance, we accumulate the fluxes. This way any variations in between timesteps are also
included, and we can output in `m³` rather than `m³s⁻¹`.

## Space {#sec-space}

The water balance equation can be applied on different spatial scales. Besides modelling a
single lumped watershed, it allows you to divide the area into a network of connected
representative elementary watersheds (REWs) [@REGGIANI1998367]. At this scale global water
balance laws can be formulated by means of integration of point-scale conservation equations
over control volumes. Such an approach makes Ribasim a semi-distributed model. In this document
we typically use the term "basin" to refer to the REW. (In Mozart the spatial unit was called
Local Surface Water (LSW)). Each basin has an associated polygon, and the set of basins is
connected to each other as described by a graph, which we call the network. Below is a
representation of both on the map.

![Mozart Local Surface Water polygons and their drainage.](https://user-images.githubusercontent.com/4471859/185932183-62c305e6-bc14-4f3c-a74c-437f831c9145.png)

The network is described as graph. Flow can be bi-directional, and the graph does not have
to be acyclic.

```{mermaid}
graph LR;
    A["basin A"] --- B["basin B"];
    A --- C["basin C"];
    B --- D["basin D"];
    C --- D;
```

Internally a directed graph is used. The direction is defined to be the
positive flow direction, and is generally set in the dominant flow direction.
The basins are the nodes of the network graph. Basin states and properties such
storage volume and wetted area are associated with the nodes (A, B, C, D), as are
most forcing data such as precipitation, evaporation, or water demand. Basin
connection properties and interbasin flows are associated with the edges (the
lines between A, B, C, and D) instead. 

Multiple basins may exist within the same spatial polygon, representing
different aspects of the surface water system (perennial ditches, ephemeral
ditches, or even surface ponding). @fig-p, @fig-s, @fig-t show the 25.0 m
rasterized primary, secondary, and tertiary surface waters as identified by BRT
TOP10NL [@pdoktopnl] in the Hupsel basin (as defined in the Mozart LSW's).
These systems may represented in multiple ways.

![Hupsel: primary surface water.](https://user-images.githubusercontent.com/13662783/187625163-d0a81bb6-7f55-4ad1-83e2-90ec1ee79740.PNG){#fig-p}

![Hupsel: secondary surface water.](https://user-images.githubusercontent.com/13662783/187625170-1acdfb41-7077-443f-b140-ae18cbf21e53.PNG){#fig-s}

![Hupsel: tertiary surface water.](https://user-images.githubusercontent.com/13662783/187625174-3eec28b5-ddbb-4870-94c3-d9e9a43f8eb4.PNG){#fig-t}

As a single basin (A) containing all surface water, discharging to its
downstream basin to the west (B):

```{mermaid}
graph LR;
    A["basin A"] --> B["basin B"];
```

Such a system may be capable of representing discharge, but it cannot represent
residence times or differences in solute concentrations: within a single basin,
drop of water is mixed instantaneously. Instead, we may the group primary (P),
secondary (S), and tertiary (T) surface waters. Then T may flow into S, S into
P, and P discharges to the downstream basin (B.)

```{mermaid}
graph LR;
    T["basin T"] --> S["basin S"];
    S --> P["basin P"]; 
    P --> B["basin B"];
```

As each (sub)basin has its own volume, low throughput (high volume, low
discharge, long residence time) and high throughput (low volume, high
discharge, short residence time) systems can be represented in a lumped manner;
of course, more detail requires more parameters.

# Usage

## Installing the compiled executable

Binaries of Ribasim CLI (command-line interface) can be downloaded from
[ribasim-artifacts](https://github.com/visr/ribasim-artifacts/releases), and are currently
available for Windows only. Download and unpack the `.zip` file. It can be placed anywhere,
however it is important that the contents of the zip file are kept together in a directory.
The Ribasim CLI executable is in the `bin` directory.

To check whether the installation was performed successfully, run `ribasim` with no
arguments in the command line.
This will give the following message:

```
Usage: ribasim 'path/to/config.toml'
```

:::{.callout-note}
The binaries are currently not up to date with the latest developments; we suggest
installing as a Julia package instead.
:::

## Installing as a Julia package

Ribasim is a [Julia](https://julialang.org/) package, that can be installed using Julia's
built in package manager, `Pkg`. For more information on how to use `Pkg`, see the
[Getting Started](https://pkgdocs.julialang.org/v1/getting-started/) page in its documentation.

Since Ribasim is not yet registered in the General registry, you have to install it using the
full url. Note that we here use `dev` to do a development install.

```julia
pkg> dev https://github.com/Deltares/Ribasim.jl
```

This will clone the git repository, put it under your home directory in `.julia/dev/Ribasim`,
and add the Ribasim package to your project environment. In order to receive updates, you
have to pull in the latest changes yourself using `git pull`.

Installation may take a while since Pkg is also installing and pre-compiling the dependencies
of Ribasim.

Once it is done, you can go back the Julia REPL and try to load Ribasim:

```julia
julia> using Ribasim
```

If you already have a simulation prepared, you can run it using:

```julia
julia> Ribasim.run("path/to/config.toml")
```

Again, there will be considerable latency. For this reason, if you expect to run Ribasim
a lot, we recommend to:

- Use Ribasim CLI if you only need `Ribasim.run` and don't need to do developments.
- Adapt a workflow that keeps your session active; the first `Ribasim.run("model.toml")` will
  take considerably more time than the second one, since more code needs to be compiled.
- Use a system image as explained in the [developer documentation](#developer.qmd) to reduce latency further

:::{.callout-tip}
## Tip: Visual Studio Code

There is a section on editors and IDEs for Julia on <https://julialang.org/>, scroll
down to see it. We use and recommend Microsoft's free editor [Visual Studio
Code](https://code.visualstudio.com/). When combined with the [Julia
extension](https://www.julia-vscode.org/) it provides a powerful and interactive
development experience.
:::

:::{.callout-tip}
## Tip: Revise.jl

If you plan to make changes to the code of Ribasim, we recommend installing the `Revise.jl`
package. This package allows you to modify code and use the changes without restarting
Julia. Install it with `add Revise` from the Pkg REPL. Then create a file called
`.julia/config/startup.jl`, and put `using Revise` there. This will load Revise every
time you start a Julia session.
:::

## Input and output files

### Configuration file

Ribasim has a single configuration file, which is written in the [TOML](https://toml.io/) format.
It contains settings, as well as paths to other input and output files.

```toml
# start- and endtime of the simulation
# can also be set to a date-time like 1979-05-27T07:32:00
starttime = 2019-01-01
endtime = 2021-01-01

# run a coupled Ribasim - MODFLOW 6 simulation
run_modflow = false  # default is false

# all timesteps are in seconds
# do water allocation for this time horizon
update_timestep = 86400.0
# save output at this interval
output_timestep = 86400.0  # default is 86400.0
# save timesteps at this interval
# note that this is internal, and is forwarded to the DiffEq solver options
# https://diffeq.sciml.ai/stable/basics/common_solver_opts/#Output-Control
saveat = 86400.0  # default is to save every step

# node IDs that will be included in the simulation
# these node IDs are referenced in the input files below
ids = [1, 2, 3]

# input files
forcing = "input/forcing.arrow"
state = "input/state.arrow"
static = "input/static.arrow"
profile = "input/profile.arrow"
node = "input/node.arrow"
edge = "input/edge.arrow"

# output file
waterbalance = "output/waterbalance.arrow"
```

Additionally, if `run_modflow = true`, a MODFLOW 6 specific section needs to be added to
the configuration file. This part is documented in [the MODFLOW 6 coupling demo](coupling-demo.qmd).

### Arrow files

The input and output files described below all share that they are tabular files, stored 
in the [Apache Arrow](https://arrow.apache.org/) file format, also known as Feather
files. This format has been chosen since it is standardized, fast, simple and flexible.
It can be read and written by many different software packages.
In Ribasim we use [Arrow.jl](https://arrow.juliadata.org/dev/).

Below we give details per file, in which we describe the schema of the table using a syntax
like this:

column    | type    | restriction
--------- | ------- | -----------
id        | Int     | -
volume    | Float64 | non-negative


This means that two columns are required, one named `id`, that contained elements
of type `Int`, and a column named `volume` that contains elements of type `Float64`. The
order of the columns does not matter, and the files are also allowed to have extra columns,
which will be ignored. In some cases there may be restrictions on the values or the ordering
of the rows. This is indicated under `restriction`.

Tables are also allowed to have rows for IDs, variables or times that are not part of
the simulation, these will be ignored. That makes it easy to prepare data for a larger
region once, and test models on a subset of the basins.

The Arrow input files can be compressed with LZ4 or Zstd compression. Furthermore, in some
of the columns, a small amount of different values are repeated many times. To reduce file
sizes it may be a good idea to apply
[dictionary encoding](https://arrow.apache.org/docs/format/Columnar.html#dictionary-encoded-layout)
to those columns.

### Node

Since we build Ribasim on top of ModelingToolkit, we can do
[component-based modeling](https://docs.sciml.ai/ModelingToolkit/stable/tutorials/spring_mass/).
The components here are [systems](https://docs.sciml.ai/ModelingToolkit/stable/basics/AbstractSystem/),
typically `ODESystem`. These components are connected together to form a larger system.
This is similar to the way a network has **nodes** that are connected along **edges**. We
mostly use the terms node and edge in this text.

Useful nodes can be water body storages that keep their own water balance, weirs, pumps,
users or suppliers of water. Counter intuitively, even systems you may think of as edges,
such as a canal, are nodes in Ribasim. This is because edges only define direct
instantaneous couplings between nodes, and never have storage of their own.

column    | type     | restriction
--------- | -------- | -----------
id        | Int      | unique
node      | String   | known type
geometry  | geoarrow | (optional)

The schema of the node table shows that only a unique ID and known node type need to be
given. The known node types as of this writing are:

- LSW
- GeneralUser_P
- LevelControl
- GeneralUser
- OutflowTable
- HeadBoundary
- Bifurcation
- LevelLink

Adding a geometry to the node table can be helpful to examine models in
[QGIS](https://qgis.org/en/site/), as it will show the location of the nodes on the map.
Geometries can be encoded in Arrow files according to the
[geoarrow specifications](https://github.com/geoarrow/geoarrow) (still in flux).
The geometry is not used by Ribasim.

### Edge

Edges define so called connections, created in ModelingToolkit using the `connect` function.
If defined between two flow connectors, they equate the level $h$, conserve the flux $Q$,
and carry the salinity $C$ in the flow direction. When defined between storage connectors,
they can function simply as a way to share available storage $S$ information from a
reservoir to a water user, such that it can avoid overextraction.

column         | type     | restriction
-------------- | -------- | -----------
from_id        | Int      | -
from_node      | String   | known type
from_connector | String   | exists for node
to_id          | Int      | -
to_node        | String   | known type
to_connector   | String   | exists for node
geometry       | geoarrow | (optional)

The names of the connectors need to match the available connectors per node type, which
are outlined below.

- LSW
  - x: flow
  - s: storage
- GeneralUser_P
  - a: flow
  - s_a: storage
- LevelControl
  - a: flow
- GeneralUser
  - x: flow
  - s: storage
- OutflowTable
  - a: upstream flow
  - b: downstream flow
  - s: storage
- HeadBoundary
  - x: flow
- Bifurcation
  - src: inflow
  - dst_{i}: split outflow in n parts
- LevelLink
  - a: flow on one side
  - b: flow on other side

Similarly to the node table, you can use a geometry to visualize the connections between
the nodes in QGIS. For instance, you can draw a line connecting the two node coordinates.

### State

The state table aims to capture the full state of the system, such that it can be used
as an initial condition, that is potentially the outcome of an earlier simulation.
Currently the only states are the volume $S$ and salinity $C$ of the LSW node.

column    | type    | restriction
--------- | ------- | -----------
id        | Int     | -
S         | Float64 | non-negative
C         | Float64 | non-negative

Each used ID needs to be in the table.

### Static

The static table can be used to set the **initial** value of variables. The forcing table
has a similar schema, with the time column added. If a variable is in the static table,
it can still be added to the forcing as well, which will update the inital value when
the given timestamp is reached.

column   | type     | restriction
-------- | -------- | -----------
id       | Int      | -
variable | String   | -
value    | Float64  | depending on variable

Note that if variables are not set in the static table, default values are used when
possible. These are generally zero, e.g. no precipitation, no inflow. If it is not possible
to have a reasonable and safe default, a value must be provided in the static table.
An example of this is the `target_volume` from the LevelLink node.

### Forcing

All dynamic data can be added to the forcing table.

column   | type     | restriction
-------- | -------- | -----------
time     | DateTime | sorted
id       | Int      | -
variable | String   | -
value    | Float64  | depending on variable

Here is an example of the first and last two rows of a forcing table:

time                |       id | variable      | value
------------------- |--------- |-------------- |-------
2019-01-01T00:00:00 |        6 | P             | 2.89352e-10
2019-01-01T00:00:00 |       16 | P             | 2.89352e-10
⋮                   | ⋮        | ⋮              | ⋮
2020-12-31T00:00:00 |       90 | E\_pot        | 1.15741e-9
2020-12-31T00:00:00 |        7 | E\_pot        | 1.15741e-9

The forcing table is a [narrow table](https://en.wikipedia.org/wiki/Wide_and_narrow_data#Narrow).
When the simulation arrives at a time given in the forcing data, it will update all the
values given for that time. These values then stay constant until the next update, there
is no interpolation in between. This also means that if a value is defined before the start
of the simulation, it is completely ignored. This format give maximum flexibility to update
different variables at different times.

### Profile

The profile table defines the physical dimensions of the storage reservoir of each basin.
Depending on the basin type, the columns are used differently. For free draining basins,
the level is not used in the calculation, but may be used to convert calculated volumes
to levels for output. For level controlled basins, the discharge is not used.

column    | type    | unit         | restriction
--------- | ------- | ------------ | -----------
id        | Int     | -            | sorted
volume    | Float64 | $m^3$        | sorted per ID and start at 0
area      | Float64 | $m^2$        | sorted per ID and non-negative
discharge | Float64 | $m^3 s^{-1}$ | sorted per ID and non-negative
level     | Float64 | $m$          | sorted per ID

The level is in meters above a datum that is the same for the entire model.
An example of the first 5 rows of such a table is given below. The first 4 rows define the
profile of ID `10020`. The number of rows can vary per ID. Using a very large
number of rows may impact performance.

id       | volume         | area          | discharge  | level
-------- |--------------- |-------------- |----------- |-------
   10020 |      0.0       |     1.36404e5 | 0.0        | -0.105
   10020 |  24726.2       |     1.36404e5 | 0.0        |  0.095
   10020 |  49452.5       |     1.36404e5 | 0.00942702 |  0.295
   10020 |      2.49735e6 |     1.36404e5 | 0.942702   | 20.095
   10037 |      0.0       | 50663.3       | 0.0        |  2.129

:::{.callout-note}
Profiles need to be defined for all LSW and OutflowTable node. OutflowTable uses only
volume and discharge, whereas LSW uses volume, area and level. These may be split up in
the future.
:::

### Water balance

The water balance table outputs all water balance terms at a regular output frequency, as
defined by `output_timestep` in the configuration file. The units are $m^3$, which is the
total volume of flow into the basin since the previous output timestep. The inital timestep
of the simulation, with all values set to zero, is also written to the file. Since flow out
of the basin is given a negative value, and the storage change is included, you can sum all
components to verify the closure of the water balance.

column   | type     | restriction
-------- | -------- | -----------
time     | DateTime | sorted
id       | Int      | -
variable | String   | -
value    | Float64  | non-negative volume ($m^3$)

The water balance table has the same schema as the forcing table. Since the output frequency
is constant, and equal for all variables, you can pivot this table from [narrow](https://en.wikipedia.org/wiki/Wide_and_narrow_data) to wide data to get the different water balance
components as columns. Having them as a narrow table can make it easier to process, since
for a given model you may not know the water balance components ahead of time.

## Example input files

From [this link](https://github.com/visr/ribasim-artifacts/releases)
you can download an existing schematization for the Netherlands that was used for testing
purposes during development. It is provided here as an example to help people get started.
Based on the description of the input files above, you can also generate your own
schematization using your tools of choice. We have used [DataFrames.jl](https://github.com/JuliaData/DataFrames.jl)
and [Arrow.jl](https://github.com/JuliaData/Arrow.jl) to prepare the tables, but one can
equally use for instance Python's [pandas](https://arrow.apache.org/docs/python/pandas.html).
