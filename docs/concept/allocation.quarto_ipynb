{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Allocation\"\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Introduction\n",
        "Allocation is the process of assigning an allocated flow rate to demand nodes in the physical layer of the model based on information about sources, the different demand nodes over various priorities, constraints introduced by nodes, local water availability and graph topology. The allocation procedure implemented in Ribasim is heavily inspired by the [maximum flow problem](https://en.wikipedia.org/wiki/Maximum_flow_problem).\n",
        "\n",
        "The allocation problem is solved per subnetwork (and main network) of the Ribasim model. Each subnetwork is used to formulate an optimization problem with the [JuMP](https://jump.dev/JuMP.jl/stable/) package, which is solved using the [HiGHS solver](https://highs.dev/). For more in-depth information see also the example of solving the maximum flow problem with `JuMP.jl` [here](https://jump.dev/JuMP.jl/stable/tutorials/linear/network_flows/#The-max-flow-problem).\n",
        "\n",
        "Before the optimization for each priority there is a simple step that tries to allocate flow to the `UserDemand` nodes from the their directly connected basin.\n",
        "\n",
        ":::{.callout-note}\n",
        "within this *Allocation* section the main network is also considered to be a subnetwork.\n",
        ":::\n",
        "\n",
        "# The high level algorithm {#sec-high-level-algorithm}\n",
        "The allocation algorithm contains 3 types of optimization:\n",
        "\n",
        "- `internal_sources`, where flows are allocated within a subnetwork by only using sources inside the subnetwork;\n",
        "- `collect_demands`, where flows are allocated within a subnetwork by only using the main network inlet(s) as a source, with demands reduced by allocations in `internal_sources`. The allocated flows in this optimization type are not used. The goal is to see the flow through the main network inlet(s), which is interpreted as the subnetwork demand;\n",
        "- `allocate`, where all available sources are used and the final allocated flows for the users are determined.\n",
        "\n",
        "The full algorithm goes through the following steps:\n",
        "\n",
        "1. Perform `internal_sources` followed by `collect_demands` for all subnetworks apart from the main network;\n",
        "2. Perform `allocate` for the main network;\n",
        "3. Perform `allocate` for the other subnetworks.\n",
        "\n",
        "If no main network is present, then 1 and 2 are skipped.\n",
        "\n",
        "# Elements of allocation\n",
        "\n",
        "The following data of the parameters and state of a Ribasim model are relevant for the allocation problem.\n",
        "\n",
        "## Schematisation input\n",
        "\n",
        "### The subnetwork\n",
        "\n",
        "The allocation problem is solved per subnetwork, which is given by a subset $S \\subset V$ of node ids. Different subnetworks are disjoint from eachother.\n",
        "\n",
        "### Source flows\n",
        "\n",
        "Sources are indicated by a set of edges in the subnetwork\n",
        "$$\n",
        "E_S^\\text{source} \\subset E.\n",
        "$$\n",
        "That is, if $(i,j) \\in E_S^\\text{source}$, then the average over the last allocation interval $\\Delta t_{\\text{alloc}}$ of the of the flow over this edge\n",
        "$$\n",
        "    \\frac{1}{\\Delta t_{\\text{alloc}}}\\int_{t - \\Delta t_{\\text{alloc}}}^tQ_{ij}(t') dt'\n",
        "$$\n",
        " is treated as a source flow in the allocation problem. These edges are either coming from a boundary/source node (e.g. a level or flow boundary) or connect the main network to a subnetwork. For the definition of $Q_{ij}$ see [the formal model description](/concept/equations.qmd#formal-model-description).\n",
        "\n",
        "### User demands\n",
        "\n",
        "The subnetwork contains a subset of UserDemand nodes $U_S \\subset S$, who all have static or time varying demands over various priorities $p$:\n",
        "$$\n",
        "    d^p_i(t), \\quad i \\in U_S, p = 1,2,\\ldots, p_{\\max}.\n",
        "$$\n",
        "\n",
        ":::{.callout-note}\n",
        "On this page we assume that the priorities are given by all integers from $1$ to some $p_{\\max} \\in \\mathbb{N}$. For the Ribasim input this is not a requirement; some of these in between priority values can be missing, only the ordering of the given priorities is taken into account.\n",
        ":::\n",
        "\n",
        "### Flow demands\n",
        "\n",
        "The subnetwork contains a subset of nodes $FD_S \\subset S$ which have a demand of a single priority $p_{\\text{fd}}$. With this we define\n",
        "$$\n",
        "    d^p_i(t) =\n",
        "    \\begin{cases}\n",
        "        0 \\text{ if } p \\ne p_{\\text{fd}} \\\\\n",
        "        d^{p_{\\text{df}}} \\text{ if } p = p_{\\text{fd}}\n",
        "    \\end{cases}\n",
        "$$\n",
        "for all $i \\in FD_S$. Here $d^{p_{\\text{df}}}$ is given by the original flow demand minus the flows trough node $i$ at all priorities $p < p_{\\text{fd}}$.\n",
        "\n",
        "## Simulation (physical layer) input\n",
        "\n",
        "### Vertical fluxes and local storage\n",
        "\n",
        "Apart from the source flows denoted by edges, there are other sources of water in the subnetwork, associated with the basins in the subnetwork $B_S = B \\cap S$. Firstly there is the average over the last allocation interval $\\Delta t_{\\text{alloc}}$ of the vertical fluxes (precipitation, evaporation, infiltration and drainage) for each basin:\n",
        "$$\n",
        "    \\phi_i(t) = \\frac{1}{\\Delta t_{\\text{alloc}}}\\int_{t - \\Delta t_{\\text{alloc}}}^t \\left[Q_{P,i}(t') - Q_{E,i}(t') + Q_{\\text{drn},i}(t') - Q_{\\text{inf},i}(t') \\right] dt', \\quad \\forall i \\in B_S.\n",
        "$$\n",
        "\n",
        "We consider fluxes into the basin to be positive and out of the basin to be negative. For more information see [the natural water balance terms](/concept/equations.qmd#natural-water-balance-terms).\n",
        "\n",
        "Secondly, there is either a supply or demand from the storage in the basin. Given a minimum level $\\ell_{\\min, i}$ and a maximum level $\\ell_{\\max, i}$ which correspond to a minimum storage $s_{\\min, i}$ and maximum storage $s_{\\max, i}$ respectively, we get a flow supply of\n",
        "$$\n",
        "    F^{\\text{basin out}}_{\\max, i} = \\max\\left(0.0, \\frac{u_i(t)-s_{\\max,i}}{\\Delta t_{\\text{alloc}}} + \\phi_i(t)\\right)\n",
        "$$\n",
        "\n",
        "and a demand of\n",
        "$$\n",
        "    d^p_i = \\max\\left(0.0, \\frac{s_{\\min,i} - u_i(t)}{\\Delta t_{\\text{alloc}}} - \\phi_i(t)\\right),\n",
        "$$\n",
        "\n",
        "for all $i \\in B_S$. Note that the basin demand has only a single priority, so for other priorities this demand is $0$.\n",
        "\n",
        "### Constraining factors\n",
        "\n",
        "#### Flow magnitude and direction constraints\n",
        "Nodes in the Ribasim model that have a `max_flow_rate`, i.e. Pump, Outlet and LinearResistance, put a constraint on the flow through that node. Some nodes only allow flow in one direction, like Pump, Outlet and TabulatedRatingCurve.\n",
        "\n",
        "#### UserDemand return flows\n",
        "UserDemand nodes dictate proportional relationships between flows over edges in the subnetwork. The return factor is given by $0 \\le r_i \\le 1, i \\in U_S$.\n",
        "\n",
        "## The subnetwork\n",
        "The subnetwork consists of a set of nodes $S \\subset V$ and edges\n",
        "\n",
        "$$\n",
        "    E_S = (S \\times S) \\cup E_S^\\text{source},\n",
        "$$\n",
        "\n",
        "i.e. the edges that lie within the subnetwork together with the source edges (which can be partially outside the subnetwork).\n",
        "The nodes in $S$ together with the connected nodes outside the subnetwork are called the extended subnetwork.\n",
        "\n",
        "### Capacities\n",
        "\n",
        "Each edge in the subnetwork has an associated capacity. These capacities are collected in the sparse capacity matrix $C_S \\in \\overline{\\mathbb{R}}_{\\ge 0}^{n\\times n}$ where $n$ is the number of nodes in the extended subnetwork. An edge capacity is infinite if there is nothing in the model constraining the capacity.\n",
        "\n",
        "The capacities are determined in different ways:\n",
        "\n",
        "- If an edge does not exist in the allocation network, i.e. $(i,j) \\notin E_S$ for certain $1 \\le i,j\\le n'$, then $(C_S)_{i,j} = 0$;\n",
        "- The capacity of the edge $e \\in E_S$ is given by the smallest `max_flow_rate` of the nodes along the equivalent edges in the subnetwork. If there are no nodes with a `max_flow_rate`, the edge capacity is infinite;\n",
        "- If the edge is a source, the capacity of the edge is given by the flow rate of that source;\n",
        "- If an edge comes from a node with a flow demand, it has infinite capacity at priorities other than this of this flow demand, and zero capacity otherwise.\n",
        "\n",
        "There are also capacities for special edges:\n",
        "\n",
        "- $C^{LD}_S \\in \\mathbb{R}^b_{\\ge 0}$ where $b = \\# B_S$ is the number of basins, for the flow supplied by basins based on level demand (this capacity is 0 for basins that have no level demand).\n",
        "- $C^{FD}_S \\in \\mathbb{R}^c_{\\ge 0}$ where $c = \\# FD_S$ is the number of nodes with a flow demand, for the flow supplied by flow buffers at these nodes with a flow demand.\n",
        "- $C^{UD}_S \\in \\mathbb{R}^f_{\\ge 0}$ where $f = \\# U_S$, for the flow supplied by the user demand outflow source whose capacity is given by return flows.\n",
        "\n",
        "# The optimization problem\n",
        "\n",
        "The optimization problem for a subnetwork is a linear optimization problem consisting of an objective function with associated constraints on a set of variables, all of which are introduced below.\n",
        "\n",
        "## The optimization variables\n",
        "\n",
        "There are several types of variable whose value has to be determined to solve the allocation problem:\n",
        "\n",
        "- The flows $F \\in \\mathbb{R}_{\\ge 0}^{n\\times n}$ over the edges in the allocation network;\n",
        "- The flows $F^\\text{basin out}_{i}, F^\\text{basin in}_{i} \\geq 0$ for all $i \\in B_S$ supplied and consumed by the basins with a level demand respectively;\n",
        "- The flows $F^\\text{buffer out}_{i}, F^\\text{buffer in}_{i} \\ge 0$ for all $i \\in FD_S \\cup FF_S$ supplied and consumed by the flow buffers of nodes with a flow demand.\n",
        "\n",
        "## The optimization objective\n",
        "\n",
        "The goal of allocation is to get the flow to nodes with demands as close as possible to these demands. To achieve this, a sum error of terms is minimized.\n",
        "\n",
        "$$\n",
        "    \\min E_{\\text{user demand}} + E_{\\text{level demand}} + E_{\\text{flow demand}}\n",
        "$$\n",
        "\n",
        "The error between the flows and user demands is denoted by $E_{\\text{user demand}}$, where\n",
        "$$\n",
        "    E_{\\text{user demand}} = \\sum_{(i,j)\\in E_S\\;:\\; i\\in U_S} d_j^p(t)\\left(1 - \\frac{F_{ij}}{d_j^p(t)}\\right)^2\n",
        "$$\n",
        "\n",
        ":::{.callout-note}\n",
        "When performing main network allocation, the connections to subnetworks are also interpreted as UserDemand nodes with demands determined by subnetwork demand collection.\n",
        ":::\n",
        "\n",
        "This type of objective cares about the fraction of the demand allocated, and will lead to an equal fraction of all demands allocated when possible. For a discussion on this see [here](https://github.com/Deltares/Ribasim/pull/1366).\n",
        "\n",
        "Likewise, the error of level demands from basins is the squared relative difference between flows consumed by basins and basin demands.\n",
        "$$\n",
        "    E_{\\text{level demand}} = \\sum_{i \\in B_S} d_i^p(t)\\left(1 - \\frac{F_i^\\text{basin in}}{d_i^p(t)}\\right)^2\n",
        "$$\n",
        "\n",
        "Lastly, the error of the flow demands is given as below.\n",
        "$$\n",
        "    E_{\\text{flow demand}} = \\sum_{i \\in FD_S} d_i^p(t)\\left(1 -  \\frac{F_i^\\text{buffer in}}{d_i^p(t)}\\right)^2\n",
        "$$\n",
        "\n",
        "## The optimization constraints\n",
        "\n",
        "For convenience, we use the notation\n",
        "\n",
        "\\begin{align}\n",
        "    V^{\\text{out}}_S(i) = \\left\\{j \\in V : (i,j) \\in E_S\\right\\} \\\\\n",
        "    V^{\\text{in}}_S(j) = \\left\\{i \\in V : (i,j) \\in E_S\\right\\}\n",
        "\\end{align}\n",
        "\n",
        "for the set of in-neighbors and out-neighbors of a node in the network respectively.\n",
        "\n",
        "- Flow conservation: For all nodes $k$ that are not a source or a sink (i.e. `FlowBoundary`, `LevelBoundary`, `UserDemand`) we have a flow conservation constraint:\n",
        "$$\n",
        "    \\sum F_{\\text{out special}} + \\sum_{j \\in V^{\\text{out}}_S(k)} F_{kj} = \\sum F_{\\text{in special}} + \\sum_{i \\in V^{\\text{in}}_S(k)} F_{ik}, \\quad \\forall k \\in B_S.\n",
        "$$  {#eq-flowconservationconstraintbasin}\n",
        "\n",
        "In here, we have the following special flows:\n",
        "\n",
        "- If $k$ is a basin with a flow demand, there is a special outflow $F^{\\text{basin in}}_k$ and a special inflow $F^{\\text{basin out}}_k$;\n",
        "- If the node has a buffer (see [here](#the-optimization-variables)) there is a special outflow $F^{\\text{buffer in}}_k$ and a special inflow $F^{\\text{buffer out}}_k$.\n",
        "\n",
        ":::{.callout-note}\n",
        "In the above, the placement of the basin and buffer flows might seem counter-intuitive. Think of the storage or buffer as a separate node connected to the node with the demand.\n",
        ":::\n",
        "\n",
        "- Capacity: the flows over the edges are bounded by the edge capacity:\n",
        "$$\n",
        "    F_{ij} \\le \\left(C_S\\right)_{ij}, \\quad \\forall(i,j) \\in E_S.\n",
        "$$ {#eq-capacityconstraint}\n",
        "By the definition of $C_S$ this also includes the source flows. The same holds for the basin outflows:\n",
        "\n",
        "$$\n",
        "    F^{\\text{basin out}}_{i} \\le F^{\\text{basin out}}_{\\max, i}, \\quad \\forall i \\in B_S.\n",
        "$$\n",
        "\n",
        ":::{.callout-note}\n",
        "When performing subnetwork demand collection, these capacities are set to $\\infty$ for edges which connect the main network to a subnetwork. For all other sources the capacity is set to $0$, so that demand collection only uses flow from the main network inlet.\n",
        ":::\n",
        "\n",
        "Similar constraints hold for the flow out of basins, flow demand buffers and user demand outflow sources:\n",
        "$$\n",
        "F^\\text{basin out}_{i} \\le (C^{FD}_S)_i, \\quad \\forall i \\in B_S,\n",
        "$$\n",
        "\n",
        "$$\n",
        "F^\\text{buffer out}_{i} \\le (C^{FD}_S)_i, \\quad \\forall i \\in FD_S,\n",
        "$$\n",
        "\n",
        "$$\n",
        "F_{ij} \\le (C^{UD}_S)_i, \\quad \\forall i \\in U_S, \\quad V_S^{\\text{out}}(i) = \\{j\\}.\n",
        "$$\n",
        "Here we use that each UserDemand node in the allocation network has a unique  outflow edge. The user outflow source capacities are increased after each optimization solve by the return fraction:\n",
        "$$\n",
        "    r_i \\cdot F_{ki}, \\quad V_S^{\\text{in}}(i) = \\{k\\}.\n",
        "$$\n",
        "\n",
        "- Flow sign: Furthermore there are the non-negativity constraints for the flows and allocations, see [The optimization variables](/concept/allocation.qmd#the-optimization-variables).\n",
        "\n",
        "\n",
        "## Example\n",
        "\n",
        "The following is an example of an optimization problem for the example shown [here](/guide/examples.ipynb#model-with-allocation-user-demand):\n"
      ],
      "id": "e8bb6c1a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "using Ribasim\n",
        "using Ribasim: NodeID\n",
        "using SQLite\n",
        "using ComponentArrays: ComponentVector\n",
        "\n",
        "toml_path = normpath(@__DIR__, \"../../generated_testmodels/allocation_example/ribasim.toml\")\n",
        "p = Ribasim.Model(toml_path).integrator.p\n",
        "u = ComponentVector(; storage = zeros(length(p.basin.node_id)))\n",
        "\n",
        "allocation_model = p.allocation.allocation_models[1]\n",
        "t = 0.0\n",
        "priority_idx = 1\n",
        "\n",
        "Ribasim.set_flow!(p.graph, 1, 1.0, u)\n",
        "Ribasim.set_objective_priority!(allocation_model, p, u, t, priority_idx)\n",
        "Ribasim.set_initial_values!(allocation_model, p, u, t)\n",
        "\n",
        "println(p.allocation.allocation_models[1].problem)"
      ],
      "id": "8e463063",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.10",
      "language": "julia",
      "display_name": "Julia 1.10.5",
      "path": "C:\\Users\\pronk_mn\\AppData\\Roaming\\jupyter\\kernels\\julia-1.10"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}